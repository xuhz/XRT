# Do NOT edit this file, it is a temporary copy to keep the
# f/w build system happy. Make any changes in the sfregistry
# repository and then "make mcdi_headers" there to
# publish the changes or alternatively "make export" to
# publish all types of header.
# That will update this file, including prepending this notice.
#

# Copyright 2020 Xilinx Inc.
#
# MCDI definitions for Programmable Region management on Riverhead and
# Keystone devices.  See SF-123619-PS for fuller details.

- blockdef: mcdi_messages
  title: MCDI MC Host Message Interface
  registers:

## Programmable Region Sessions #############################################

  - msgset: MC_CMD_PR_OPEN @ 0x1A2 @ GENERAL
    summary: Open a session to manage a programmable region.
    i: >
      Open a session to manage a programmable region. Session handles can be
      explicitly closed with MC_CMD_PR_CLOSE, or implicitly via
      MC_CMD_ENTITY_RESET or a PCIe Function Level Reset.
      Although this command is available to all callers that are a member of
      the GENERAL privilege group, an additional privilege check may be
      performed against the target region.
      Returns ENODEV if the region doesn't exist; EPERM if the caller has
      insufficient privilege to open the region; EBUSY is the rgion is
      currently busy; ENOSPC if the caller has too many open programmable
      region sessions.
    private: yes # Interface under development; subject to change.
    msgs:
    - msgrequest: MC_CMD_PR_OPEN_IN
      fields:
      - field: REGION_ID[31:0]
        i: The programmable region to open.
    - msgresponse: MC_CMD_PR_OPEN_OUT
      fields:
      - field: HANDLE[31:0]
        i: >
          Session handle for operations on the contents of the programmable
          region. Handles should be considered opaque, although a value of
          0xFFFFFFFF is guaranteed never to be a valid handle.
        enums:
          - enum: HANDLE_NULL = 0xFFFFFFFF
            i: Invalid programmable region session handle

  - msgset: MC_CMD_PR_CLOSE @ 0x1A3 @ GENERAL
    summary: Close a session created with MC_CMD_PR_OPEN.
    i: >
      Close a session created with MC_CMD_PR_OPEN.
      Returns ENOENT if the session handle doesn't exist.
    private: yes # Interface under development; subject to change.
    msgs:
    - msgrequest: MC_CMD_PR_CLOSE_IN
      fields:
      - field: HANDLE[31:0]
        i: Session handle from MC_CMD_PR_OPEN_OUT
    - msgresponse: MC_CMD_PR_CLOSE_OUT

## Programmable Region Update ###############################################

  - msgset: MC_CMD_PR_TRANSFER_BEGIN @ 0x1A4 @ GENERAL
    summary: Starts transfer of a XCLBIN to a programmable region
    i: >
      Starts transfer of a XCLBIN to the target region associated with a
      session, setting the target region's data transfer offset to 0.
      Although this command is available to all callers that are a member of
      the GENERAL privilege group an extra privilege check may be performed
      against the target region in addition to the check performed by
      MC_CMD_PR_OPEN.
      Returns ENOENT if the session handle doesn't exist; EPERM if the
      caller has insufficient privilege to update the target region; EBUSY if
      the target region is currently busy; ESTALE if the target region has
      been updated since the session was opened. The caller should close this
      handle and open a new session to retry its transfer; EINVAL if length
      is too small, e.g. smaller than the AXLF/XCLBIN2 header; ENOMEM if
      length too large, e.g. larger than the resources available to buffer
      the transfer.
    private: yes # Interface under development; subject to change.
    msgs:
    - msgrequest: MC_CMD_PR_TRANSFER_BEGIN_IN
      fields:
      - field: HANDLE[31:0]
        i: Session handle from MC_CMD_PR_OPEN_OUT
      - field: LENGTH[95:32]
        i: The length (in bytes) of the XCLBIN data to be transferred.
    - msgresponse: MC_CMD_PR_TRANSFER_BEGIN_OUT

  - msgset: MC_CMD_PR_TRANSFER_WRITE @ 0x1A5 @ GENERAL
    summary: Transfer a chunk of XCLBIN data to a programmable region
    i: >
      Transfer a chunk of a XCLBIN data to the target region of a session,
      advancing the current data transfer offset. Chunks are transferred in a
      streaming like way and it is the responsibility of the caller to ensure
      all chunks are transferred in order and with no duplicates.
      Requires a transfer to have been started with MC_CMD_PR_TRANSFER_BEGIN.
      Returns ENOENT if the session handle doesn't exist; EACCESS if the the
      session does not have an in-progress transfer; ESTALE if session's
      transfer has been cancelled, e.g. another session has started a
      transfer; ERANGE if the chunk exceeds the total transfer length
      specified in MC_CMD_PR_TRANSFER_BEGIN_IN.
    private: yes # Interface under development; subject to change.
    msgs:
    - msgrequest: MC_CMD_PR_TRANSFER_WRITE_IN
      fields:
      - field: HANDLE[31:0]
        i: Session handle from MC_CMD_PR_OPEN_OUT
      - field: DATA[39:32][1-MAX]
        i: Chunk of data to write
    - msgresponse: MC_CMD_PR_TRANSFER_WRITE_OUT

  - msgset: MC_CMD_PR_TRANSFER_END @ 0x1A6 @ GENERAL
    summary: End the transfer of a XCLBIN to a programmable region
    i: >
      End the transfer of a XCLBIN to the target region of a session. A
      success result indicates the firmware started the update process. If
      the the XCLBIN data is accepted, and programming has started, all other
      sessions for the same target region will be marked stale. The caller
      can use MC_CMD_PR_STATUS_GET to determine the overall result of the
      update.
      Requires a transfer to have been started with MC_CMD_PR_TRANSFER_BEGIN.
      Returns ENOENT if the session handle doesn't exist; EACCESS if the the
      session does not have an in-progress transfer; ESTALE if session's
      transfer has been cancelled, e.g. another session has started a
      transfer.
    private: yes # Interface under development; subject to change.
    msgs:
    - msgrequest: MC_CMD_PR_TRANSFER_END_IN
      fields:
      - field: HANDLE[31:0]
        i: Session handle from MC_CMD_PR_OPEN_OUT
    - msgresponse: MC_CMD_PR_TRANSFER_END_OUT

  - msgset: MC_CMD_PR_STATUS_GET @ 0x1A7 @ GENERAL
    summary: Query the current update status of a programmable region
    i: >
      Query the current update status of the target region of a session.
      Returns ENOENT if the session handle doesn't exist; ESTALE if the
      target region has been updated by another session since the session was
      opened.
    private: yes # Interface under development; subject to change.
    msgs:
    - msgrequest: MC_CMD_PR_STATUS_IN
      fields:
      - field: HANDLE[31:0]
        i: Session handle from MC_CMD_PR_OPEN_OUT
    - msgresponse: MC_CMD_PR_STATUS_OUT
      fields:
      - field: STATUS[31:0]
        i: >
          The state of the last update attempt triggered by
          MC_CMD_PR_TRANSFER_END
        enums:
          - enum: STATUS_PENDING = 0
            i: Update in progress
          - enum: STATUS_SUCCESS = 1
            i: Update successful, or no update attempted since device boot
          - enum: STATUS_ERROR   = 2
            i: Update failed
      - field: RESULT[63:32]
        i: >
          Code providing more information about the state of the update
          process. The specific result codes are not defined by MCDI.
      - field: DESCRIPTION[71:64][1-MAX]
        i: Result description (NUL-terminated ASCII string)

## Programmable Region Meta-data Query ######################################

  - enumdef: PR_METADATA_ITEM_CATEGORY
    summary: Meta-data item category
    i: Meta-data item category
    private: yes # Interface under development; subject to change.
    enums:
      - enum: SECTION   = 0
        i: A XCLBIN meta-data section
      - enum: UUID      = 1
        i: The active XCLBIN's UUID (axlf_header::uuid)
      - enum: TIMESTAMP = 2
        i: The active XCLBIN's timestamp (axlf_header::m_timeStamp)
      - enum: SIGNATURE = 3
        i: >
          The active XCLBIN's signature (the last axlf::m_signature_length
          bytes of the XCLBIN data)

  - enumdef: PR_METADATA_ITEM_SUBCATEGORY
    summary: Meta-data item sub-category
    i: >
      Meta-data item sub-category.
      For the SECTION category the subcategory matches AXLF section type
      identifiers (enum axlf_section_kind) and each subcategory contains
      an array of items as the AXLF container format supports multiple
      sections of the same type.
      Other categories (UUID, TIMESTAMP and SIGNATURE) do not currently
      use subcategories and must be 0 (NONE).
    private: yes # Interface under development; subject to change.
    enums:
      - enum: NONE                  =  0
      - enum: BITSTREAM             =  0
      - enum: CLEARING_BITSTREAM    =  1
      - enum: EMBEDDED_METADATA     =  2
      - enum: FIRMWARE              =  3
      - enum: DEBUG_DATA            =  4
      - enum: SCHED_FIRMWARE        =  5
      - enum: MEM_TOPOLOGY          =  6
      - enum: CONNECTIVITY          =  7
      - enum: IP_LAYOUT             =  8
      - enum: DEBUG_IP_LAYOUT       =  9
      - enum: DESIGN_CHECK_POINT    = 10
      - enum: CLOCK_FREQ_TOPOLOGY   = 11
      - enum: MCS                   = 12
      - enum: BMC                   = 13
      - enum: BUILD_METADATA        = 14
      - enum: KEYVALUE_METADATA     = 15
      - enum: USER_METADATA         = 16
      - enum: DNA_CERTIFICATE       = 17
      - enum: PDI                   = 18
      - enum: BITSTREAM_PARTIAL_PDI = 19
      - enum: PARTITION_METADATA    = 20
      - enum: EMULATION_DATA        = 21
      - enum: SYSTEM_METADATA       = 22
      - enum: SOFT_KERNEL           = 23
      - enum: ASK_FLASH             = 24
      - enum: AIE_METADATA          = 25

  - msgset: MC_CMD_PR_METADATA_INFO @ 0x1A8 @ GENERAL
    summary: Query information about the meta-data of a programmable region
    i: >
      Query information (length and name) about the meta-data describing the
      active contents of the target region of a session.
      Returns ENOENT if the session handle doesn't exist; ESTALE if the
      target region has been updated by another session since the session was
      opened; ENODEV if the meta-data item doesn't exist.
    private: yes # Interface under development; subject to change.
    msgs:
    - msgrequest: MC_CMD_PR_METADATA_INFO_IN
      fields:
      - field: HANDLE[31:0]
        i: Session handle from MC_CMD_PR_OPEN_OUT
      - field: CATEGORY[63:32]
        i: Item category
        copyenums: PR_METADATA_ITEM_CATEGORY
      - field: SUBCATEGORY[95:64]
        i: Item sub-category
        copyenums: PR_METADATA_ITEM_SUBCATEGORY
      - field: INDEX[127:96]
        i: Item index
    - msgresponse: MC_CMD_PR_METADATA_INFO_OUT
      fields:
      - field: ITEM_LENGTH[63:0]
        i: Length (in bytes) of the meta-data item
      - field: ITEM_NAME[71:64][128]
        i: >
          Meta-data item name (NUL-terminated ASCII string).
          For the SECTION category the name is AXLF section name
          (axlf_section_header::m_sectionName).
          The items of the categories (UUID, TIMESTAMP and SIGNATURE) are
          unnamed items and return an empty string (NAME[0] == '\0').

  - msgset: MC_CMD_PR_METADATA_READ @ 0x1A9 @ GENERAL
    summary: Read meta-data describing the contents of a programmable region
    i: >
      Read a chunk of the meta-data describing the active contents of the
      target region of a session.
      Returns ENOENT if the session handle doesn't exist; ESTALE if the
      target region has been updated by another session since the session was
      opened; ENODEV if the meta-data item doesn't exist; ERANGE if the
      offset is outside the valid range for the meta-data item, e.g.
      offset >= item_length.
    private: yes # Interface under development; subject to change.
    msgs:
    - msgrequest: MC_CMD_PR_METADATA_READ_IN
      fields:
      - field: HANDLE[31:0]
        i: Session handle from MC_CMD_PR_OPEN_OUT
      - field: CATEGORY[63:32]
        i: Item category
        copyenums: PR_METADATA_ITEM_CATEGORY
      - field: SUBCATEGORY[95:64]
        i: Item sub-category
        copyenums: PR_METADATA_ITEM_SUBCATEGORY
      - field: INDEX[127:96]
        i: Item index
      - field: OFFSET[191:128]
        i: Byte offset within meta-data chunk
      - field: MAX_LENGTH[207:192]
        i: Maximum length (in bytes) to read
    - msgresponse: MC_CMD_PR_METADATA_READ_OUT
      fields:
      - field: DATA[7:0][1-MAX]
        i: Chunk of meta-data

## Programmable Region Clock Control ########################################

  - structuredef: PR_FREQ_INFO
    i: Information about a single programmable region clock
    private: yes # Interface under development; subject to change.
    fields:
    - field: TYPE[31:0]
      i: >
        Clock type, a programmable region may have multiple clocks of the
        same type. (matches enum CLOCK_TYPE)
      enums:
      - enum: CLOCK_TYPE_UNUSED = 0
        i: Unused/reserved.
      - enum: CLOCK_TYPE_DATA   = 1
        i: Data clock.
      - enum: CLOCK_TYPE_KERNEL = 2
        i: Kernel clock.
      - enum: CLOCK_TYPE_SYSTEM = 3
        i: System clock.
    - field: FREQ_HQ[95:32]
      i: Clock frequency (in Hz)
    - field: NAME[103:96][128]
      i: Clock name (NUL-terminated ASCII string)

  - msgset: MC_CMD_PR_FREQ_GET @ 0x1AA @ GENERAL
    summary: Query the current clock frequencies of a programmable region
    i: >
      Query the current clock frequencies of the target region of a session.
      If the target region is 'empty' then an empty response should be
      returned.
      Returns ENOENT if the session handle doesn't exist; ESTALE if the
      target region has been updated by another session since the session was
      opened.
    private: yes # Interface under development; subject to change.
    msgs:
    - msgrequest: MC_CMD_PR_FREQ_GET_IN
      fields:
      - field: HANDLE[31:0]
        i: Session handle from MC_CMD_PR_OPEN_OUT
    - msgresponse: MC_CMD_PR_FREQ_GET_OUT
      fields:
      - field: INFOS[1119:0][0-MAX]
        i: An array of PR_FREQ_INFO structures.

  - msgset: MC_CMD_PR_FREQ_SET @ 0x1AB @ GENERAL
    summary: Set the desired clock frequencies of a programmable region
    i: >
      Set the desired clock frequencies of the target region of a session.
      The FREQ_HZ array must contain the same number of entries as the output
      to MC_CMD_PR_FREQ_GET. Callers should expect that the resulting
      frequencies may not precisely match the input and can use
      MC_CMD_PR_FREQ_GET to determine the actual frequencies selected. The
      algorithm for selecting the resulting clock settings is a firmware
      implementation detail based on the capabilities of the device and the
      target region. It is expected that the firmware will not exceed the
      desired frequency for any clock; will successfully apply a frequency
      value obtained from MC_CMD_PR_FREQ_GET without further adjustment; will
      either change all or none of the clocks.
      Although this command is available to all callers that are a member of
      the GENERAL privilege group an extra privilege check may be performed
      against the target region in addition to tbe check performed by
      MC_CMD_PR_OPEN.
      Returns ENOENT if the session handle doesn't exist; ESTALE if the
      target region has been updated by another session since the session was
      opened; EINVAL if the target region is 'empty' or the wrong number of
      desired clock frequencies was specified in the input; ERANGE if one
      or more desired clock frequencies were not achievable.
    private: yes # Interface under development; subject to change.
    msgs:
    - msgrequest: MC_CMD_PR_FREQ_SET_IN
      fields:
      - field: HANDLE[31:0]
        i: Session handle from MC_CMD_PR_OPEN_OUT
      - field: FREQ_HZ[95:32][1-MAX]
        i: Desired frequency for each clock
    - msgresponse: MC_CMD_PR_FREQ_SET_OUT
